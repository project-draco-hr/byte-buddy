{
  MethodRegistry.Compiled compiledMethodRegistry=methodRegistry.prepare(new InstrumentedType.Default(namingStrategy.name(new NamingStrategy.UnnamedType.Default(targetType.getSuperType(),interfaceTypes,modifiers,classFileVersion)),modifiers,targetType.getTypeVariables().accept(new GenericTypeDescription.Visitor.Substitutor.ForDetachment(is(targetType))),targetType.getSuperType(),interfaceTypes,fieldTokens,methodTokens,targetType.getDeclaredAnnotations(),InstrumentedType.TypeInitializer.None.INSTANCE,LoadedTypeInitializer.NoOp.INSTANCE,targetType.getDeclaringType(),targetType.getEnclosingMethod(),targetType.getEnclosingType(),targetType.isMemberClass(),targetType.isAnonymousClass(),targetType.isLocalClass()),methodGraphCompiler,InliningImplementationMatcher.of(ignoredMethods,targetType)).compile(new SubclassImplementationTarget.Factory(SubclassImplementationTarget.OriginTypeResolver.LEVEL_TYPE));
  return TypeWriter.Default.<T>forRedefinition(compiledMethodRegistry,fieldRegistry.compile(compiledMethodRegistry.getInstrumentedType()),auxiliaryTypeNamingStrategy,classVisitorWrapperChain,attributeAppender,classFileVersion,classFileLocator,targetType).make();
}
