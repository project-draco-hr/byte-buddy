{
  when(methodPoolEntry.isDefineMethod()).thenReturn(true);
  when(methodPoolEntry.getAttributeAppender()).thenReturn(methodAttributeAppender);
  when(methodPoolEntry.getByteCodeAppender()).thenReturn(byteCodeAppender);
  when(byteCodeAppender.appendsCode()).thenReturn(true);
  when(byteCodeAppender.apply(Matchers.any(MethodVisitor.class),Matchers.any(Instrumentation.Context.class),Matchers.any(MethodDescription.class))).thenReturn(new ByteCodeAppender.Size(0,0));
  MethodDescription methodDescription=MethodDescription.Latent.typeInitializerOf(instrumentedType);
  typeExtensionDelegate.cache(stackManipulation,typeDescription);
  TypeWriter.MethodPool methodPool=typeExtensionDelegate.wrapForTypeInitializerInterception(this.methodPool);
  TypeWriter.MethodPool.Entry entry=methodPool.target(methodDescription);
  assertThat(entry.isDefineMethod(),is(true));
  assertThat(entry.getByteCodeAppender().appendsCode(),is(true));
  ByteCodeAppender.Size size=entry.getByteCodeAppender().apply(methodVisitor,instrumentationContext,methodDescription);
  assertThat(size.getOperandStackSize(),is(0));
  assertThat(size.getLocalVariableSize(),is(0));
  verify(methodVisitor).visitFieldInsn(eq(Opcodes.PUTSTATIC),eq(BAR),Matchers.startsWith(CACHED_VALUE),eq(QUX));
  verify(byteCodeAppender).apply(methodVisitor,instrumentationContext,methodDescription);
  verifyNoMoreInteractions(byteCodeAppender);
  verifyNoMoreInteractions(methodVisitor);
  verifyZeroInteractions(instrumentationContext);
}
