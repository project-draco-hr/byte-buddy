{
  final int sourceIndex=2, targetIndex=1;
  when(stackManipulation.isValid()).thenReturn(true);
  when(annotation.value()).thenReturn(sourceIndex);
  when(annotation.bindingMechanic()).thenReturn(bindingMechanic);
  when(sourceParameters.size()).thenReturn(sourceIndex + 1);
  when(sourceParameters.get(sourceIndex)).thenReturn(sourceType);
  when(source.getParameterTypes()).thenReturn(sourceParameters);
  when(source.isStatic()).thenReturn(false);
  when(targetParameters.size()).thenReturn(targetIndex + 1);
  when(targetParameters.get(targetIndex)).thenReturn(targetType);
  when(target.getParameterTypes()).thenReturn(targetParameters);
  when(target.getParameterAnnotations()).thenReturn(annotations);
  MethodDelegationBinder.ParameterBinding<?> parameterBinding=Argument.Binder.INSTANCE.bind(annotation,targetIndex,source,target,instrumentedType,assigner);
  assertThat(parameterBinding.isValid(),is(true));
  Object expectedToken=new MostSpecificTypeResolver.ParameterIndexToken(sourceIndex);
  if (bindingMechanic == Argument.BindingMechanic.UNIQUE) {
    assertThat(parameterBinding.getIdentificationToken(),equalTo(expectedToken));
    assertThat(parameterBinding.getIdentificationToken().hashCode(),equalTo(expectedToken.hashCode()));
  }
 else {
    assertThat(parameterBinding.getIdentificationToken(),not(equalTo(expectedToken)));
    assertThat(parameterBinding.getIdentificationToken().hashCode(),not(equalTo(expectedToken.hashCode())));
  }
  verify(annotation,atLeast(1)).value();
  verify(source,atLeast(1)).getParameterTypes();
  verify(target,atLeast(1)).getParameterTypes();
  verify(target,atLeast(1)).getParameterAnnotations();
  verify(assigner).assign(sourceType,targetType,considerRuntimeType);
  verifyNoMoreInteractions(assigner);
}
