{
  Set<MethodDescription.Token> locallyProcessedMethods=new HashSet<MethodDescription.Token>(processedMethodsInHierarchy);
  if (processedTypes.add(typeDescription)) {
    defaultMethodLookup.begin(typeDescription);
    for (    MethodDescription methodDescription : typeDescription.getDeclaredMethods().filter(virtualMethodMatcher)) {
      MethodDescription.Token methodToken=methodDescription.asToken();
      if (locallyProcessedMethods.add(methodToken)) {
        MethodDescription conflictingMethod=interfaceMethods.get(methodToken);
        MethodDescription resolvedMethod=methodDescription;
        if (conflictingMethod != null && !conflictingMethod.getDeclaringType().asRawType().isAssignableFrom(typeDescription)) {
          resolvedMethod=ConflictingInterfaceMethod.of(typeOfInterest,conflictingMethod,methodDescription);
        }
        interfaceMethods.put(methodToken,resolvedMethod);
      }
      defaultMethodLookup.register(methodDescription);
    }
    for (    TypeDescription interfaceType : typeDescription.getInterfaces().asRawTypes()) {
      pushInterface(interfaceType,locallyProcessedMethods,defaultMethodLookup);
    }
    defaultMethodLookup.complete(typeDescription);
  }
}
