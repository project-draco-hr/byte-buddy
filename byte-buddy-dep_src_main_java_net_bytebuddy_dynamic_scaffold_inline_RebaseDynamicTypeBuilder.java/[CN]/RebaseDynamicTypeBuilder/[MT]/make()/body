{
  MethodRegistry.Prepared preparedMethodRegistry=methodRegistry.prepare(new InstrumentedType.Default(namingStrategy.name(new NamingStrategy.UnnamedType.Default(targetType.getSuperType().asRawType(),interfaceTypes,modifiers,classFileVersion)),modifiers,Collections.<GenericTypeDescription>emptyList(),targetType.getSuperType(),interfaceTypes,fieldTokens,methodTokens,targetType.getDeclaredAnnotations(),InstrumentedType.TypeInitializer.None.INSTANCE,LoadedTypeInitializer.NoOp.INSTANCE,targetType.getDeclaringType(),targetType.getEnclosingMethod(),targetType.getEnclosingType(),targetType.isMemberClass(),targetType.isAnonymousClass(),targetType.isLocalClass()),methodLookupEngineFactory.make(classFileVersion.isSupportsDefaultMethods()),InliningImplementationMatcher.of(ignoredMethods,targetType));
  MethodRebaseResolver methodRebaseResolver=MethodRebaseResolver.Enabled.make(preparedMethodRegistry.getInstrumentedMethods(),preparedMethodRegistry.getInstrumentedType(),classFileVersion,auxiliaryTypeNamingStrategy,methodNameTransformer);
  MethodRegistry.Compiled compiledMethodRegistry=preparedMethodRegistry.compile(new RebaseImplementationTarget.Factory(bridgeMethodResolverFactory,methodRebaseResolver));
  return TypeWriter.Default.<T>forRebasing(compiledMethodRegistry,fieldRegistry.prepare(compiledMethodRegistry.getInstrumentedType()).compile(TypeWriter.FieldPool.Entry.NoOp.INSTANCE),auxiliaryTypeNamingStrategy,classVisitorWrapperChain,attributeAppender,classFileVersion,classFileLocator,targetType,methodRebaseResolver).make();
}
