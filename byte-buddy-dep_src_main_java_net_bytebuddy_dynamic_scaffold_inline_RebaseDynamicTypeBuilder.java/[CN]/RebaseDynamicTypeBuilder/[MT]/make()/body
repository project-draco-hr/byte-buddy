{
  MethodRegistry.Prepared preparedMethodRegistry=methodRegistry.prepare(instrumentedType,methodGraphCompiler,InliningImplementationMatcher.of(ignoredMethods,originalType));
  MethodList<MethodDescription.InDefinedShape> rebaseableMethods=preparedMethodRegistry.getInstrumentedMethods().asDefined().filter(methodRepresentedBy(anyOf(originalType.getDeclaredMethods().asTokenList())));
  MethodRebaseResolver methodRebaseResolver=MethodRebaseResolver.Default.make(preparedMethodRegistry.getInstrumentedType(),rebaseableMethods,classFileVersion,auxiliaryTypeNamingStrategy,methodNameTransformer);
  MethodRegistry.Compiled compiledMethodRegistry=preparedMethodRegistry.compile(new RebaseImplementationTarget.Factory(rebaseableMethods,methodRebaseResolver));
  return TypeWriter.Default.<T>forRebasing(compiledMethodRegistry,fieldRegistry.compile(compiledMethodRegistry.getInstrumentedType()),typeAttributeAppender,asmVisitorWrapper,classFileVersion,annotationValueFilterFactory,annotationRetention,auxiliaryTypeNamingStrategy,implementationContextFactory,originalType,classFileLocator,methodRebaseResolver).make();
}
