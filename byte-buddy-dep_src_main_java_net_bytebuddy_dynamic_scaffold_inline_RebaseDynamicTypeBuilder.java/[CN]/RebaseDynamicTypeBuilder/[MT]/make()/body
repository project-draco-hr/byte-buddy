{
  MethodRegistry.Prepared preparedMethodRegistry=methodRegistry.prepare(instrumentedType,methodGraphCompiler,InliningImplementationMatcher.of(ignored,originalType));
  MethodList<MethodDescription.InDefinedShape> rebaseableMethods=preparedMethodRegistry.getInstrumentedMethods().asDefined().filter(methodRepresentedBy(anyOf(originalType.getDeclaredMethods().asTokenList())));
  MethodRebaseResolver methodRebaseResolver=MethodRebaseResolver.Default.make(preparedMethodRegistry.getInstrumentedType(),rebaseableMethods,classFileVersion,auxiliaryTypeNamingStrategy,methodNameTransformer);
  MethodRegistry.Compiled compiledMethodRegistry=preparedMethodRegistry.compile(new RebaseImplementationTarget.Factory(rebaseableMethods,methodRebaseResolver));
  return TypeWriter.Default.<T>forRebasing(compiledMethodRegistry,fieldRegistry.compile(compiledMethodRegistry.getInstrumentedType()),auxiliaryTypeNamingStrategy,implementationContextFactory,asmVisitorWrapper,typeAttributeAppender,classFileVersion,classFileLocator,originalType,methodRebaseResolver,annotationValueFilterFactory).make();
}
