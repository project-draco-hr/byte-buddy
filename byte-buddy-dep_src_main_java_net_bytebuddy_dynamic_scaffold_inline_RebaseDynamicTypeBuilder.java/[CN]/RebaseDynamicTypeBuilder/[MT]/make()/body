{
  MethodRegistry.Prepared preparedMethodRegistry=methodRegistry.prepare(new InstrumentedType.Default(namingStrategy.name(new NamingStrategy.UnnamedType.Default(originalType.getSuperType(),interfaceTypes,modifiers,classFileVersion)),modifiers,originalType.getTypeVariables().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(is(originalType))),originalType.getSuperType(),interfaceTypes,fieldTokens,methodTokens,originalType.getDeclaredAnnotations(),typeInitializer,LoadedTypeInitializer.NoOp.INSTANCE,originalType.getDeclaringType(),originalType.getEnclosingMethod(),originalType.getEnclosingType(),originalType.getDeclaredTypes(),originalType.isMemberClass(),originalType.isAnonymousClass(),originalType.isLocalClass()),methodGraphCompiler,InliningImplementationMatcher.of(ignoredMethods,originalType));
  MethodList<MethodDescription.InDefinedShape> rebaseableMethods=preparedMethodRegistry.getInstrumentedMethods().asDefined().filter(methodRepresentedBy(anyOf(originalType.getDeclaredMethods().asTokenList())));
  MethodRebaseResolver methodRebaseResolver=MethodRebaseResolver.Default.make(preparedMethodRegistry.getInstrumentedType(),rebaseableMethods,classFileVersion,auxiliaryTypeNamingStrategy,methodNameTransformer);
  MethodRegistry.Compiled compiledMethodRegistry=preparedMethodRegistry.compile(new RebaseImplementationTarget.Factory(rebaseableMethods,methodRebaseResolver));
  return TypeWriter.Default.<T>forRebasing(compiledMethodRegistry,fieldRegistry.compile(compiledMethodRegistry.getInstrumentedType()),auxiliaryTypeNamingStrategy,implementationContextFactory,classVisitorWrapper,attributeAppender,classFileVersion,classFileLocator,originalType,methodRebaseResolver).make();
}
