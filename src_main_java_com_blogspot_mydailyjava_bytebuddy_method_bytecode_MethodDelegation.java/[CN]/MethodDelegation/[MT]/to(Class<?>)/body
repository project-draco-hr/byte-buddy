{
  if (type.isInterface()) {
    throw new IllegalArgumentException("Cannot delegate to interface " + type);
  }
 else   if (type.isArray()) {
    throw new IllegalArgumentException("Cannot delegate to array " + type);
  }
 else   if (type.isPrimitive()) {
    throw new IllegalArgumentException("Cannot delegate to primitive " + type);
  }
  return new MethodDelegation(new AnnotationDrivenBinder(Arrays.<AnnotationDrivenBinder.ArgumentBinder<?>>asList(Argument.Binder.INSTANCE,This.Binder.INSTANCE),Argument.NextUnboundAsDefaultProvider.INSTANCE,new VoidAwareAssigner(new PrimitiveTypeAwareAssigner(ReferenceTypeAwareAssigner.INSTANCE),false)),new MethodDelegationBinder.AmbiguityResolver.Chain(Arrays.<MethodDelegationBinder.AmbiguityResolver>asList(MethodNameEqualityResolver.INSTANCE,MostSpecificTypeResolver.INSTANCE)),MethodExtraction.matching(isStatic().and(not(signatureIsDefinedIn(Object.class)))).extractFrom(type).asList());
}
