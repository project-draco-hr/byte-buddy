{
  Map<String,Class<?>> loadedTypes=new HashMap<String,Class<?>>();
  for (  Class<?> type : instrumentation.getInitiatedClasses(classLoader)) {
    loadedTypes.put(type.getName(),type);
  }
  Map<Class<?>,ClassDefinition> classDefinitions=new ConcurrentHashMap<Class<?>,ClassDefinition>();
  Map<TypeDescription,Class<?>> loadedClasses=new HashMap<TypeDescription,Class<?>>();
  Map<TypeDescription,byte[]> unloadedClasses=new LinkedHashMap<TypeDescription,byte[]>();
  for (  Map.Entry<TypeDescription,byte[]> entry : types.entrySet()) {
    Class<?> type=loadedTypes.get(entry.getKey().getName());
    if (type != null) {
      classDefinitions.put(type,new ClassDefinition(type,entry.getValue()));
      loadedClasses.put(entry.getKey(),type);
    }
 else {
      unloadedClasses.put(entry.getKey(),entry.getValue());
    }
  }
  try {
    engine.apply(instrumentation,classDefinitions);
    ClassInjector classInjector=classLoader == null ? bootstrapInjection.make(instrumentation) : new ClassInjector.UsingReflection(classLoader);
    loadedClasses.putAll(classInjector.inject(unloadedClasses));
  }
 catch (  ClassNotFoundException exception) {
    throw new IllegalArgumentException("Could not locate classes for redefinition",exception);
  }
catch (  UnmodifiableClassException exception) {
    throw new IllegalStateException("Cannot redefine specified class",exception);
  }
  return loadedClasses;
}
