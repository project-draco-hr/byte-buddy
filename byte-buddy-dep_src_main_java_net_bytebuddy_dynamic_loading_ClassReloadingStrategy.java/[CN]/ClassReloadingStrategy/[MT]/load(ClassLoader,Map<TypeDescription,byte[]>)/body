{
  Map<TypeDescription,Class<?>> loadedClasses=new HashMap<TypeDescription,Class<?>>(types.size());
  Map<TypeDescription,byte[]> unloadedClasses=new HashMap<TypeDescription,byte[]>(types.size());
  Map<Class<?>,ClassDefinition> classDefinitions=new ConcurrentHashMap<Class<?>,ClassDefinition>(types.size());
  for (  Map.Entry<TypeDescription,byte[]> entry : types.entrySet()) {
    try {
      Class<?> type=classLoader.loadClass(entry.getKey().getName());
      classDefinitions.put(type,new ClassDefinition(type,entry.getValue()));
      loadedClasses.put(entry.getKey(),type);
    }
 catch (    ClassNotFoundException ignored) {
      unloadedClasses.put(entry.getKey(),entry.getValue());
    }
  }
  try {
    engine.apply(instrumentation,classDefinitions);
    ClassInjector classInjector=classLoader == null ? bootstrapInjection.make(instrumentation) : new ClassInjector.UsingReflection(classLoader);
    loadedClasses.putAll(classInjector.inject(unloadedClasses));
  }
 catch (  ClassNotFoundException exception) {
    throw new IllegalArgumentException("Could not locate classes for redefinition",exception);
  }
catch (  UnmodifiableClassException exception) {
    throw new IllegalStateException("Cannot redefine specified class",exception);
  }
  return loadedClasses;
}
