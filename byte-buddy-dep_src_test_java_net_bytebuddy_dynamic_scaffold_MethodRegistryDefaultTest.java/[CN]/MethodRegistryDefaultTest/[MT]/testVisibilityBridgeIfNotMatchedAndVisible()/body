{
  when(instrumentedMethod.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
  when(parameterDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
  when(resolvedMethodFilter.matches(instrumentedMethod)).thenReturn(true);
  when(firstFilter.matches(instrumentedMethod)).thenReturn(false);
  when(secondFilter.matches(instrumentedMethod)).thenReturn(false);
  when(resolvedMethodFilter.matches(instrumentedMethod)).thenReturn(true);
  TypeDescription declaringType=mock(TypeDescription.class);
  when(declaringType.asErasure()).thenReturn(declaringType);
  when(instrumentedMethod.getDeclaringType()).thenReturn(declaringType);
  when(thirdType.isPublic()).thenReturn(true);
  when(instrumentedMethod.isPublic()).thenReturn(true);
  when(declaringType.isPackagePrivate()).thenReturn(true);
  TypeDescription.Generic superClass=mock(TypeDescription.Generic.class);
  TypeDescription rawSuperClass=mock(TypeDescription.class);
  when(superClass.asErasure()).thenReturn(rawSuperClass);
  when(typeDescription.getSuperClass()).thenReturn(superClass);
  MethodDescription.Token methodToken=mock(MethodDescription.Token.class);
  when(instrumentedMethod.asToken(ElementMatchers.is(typeDescription))).thenReturn(methodToken);
  when(methodToken.accept(any(TypeDescription.Generic.Visitor.class))).thenReturn(methodToken);
  when(classFileVersion.isAtLeast(ClassFileVersion.JAVA_V5)).thenReturn(true);
  MethodRegistry.Compiled methodRegistry=new MethodRegistry.Default().append(firstMatcher,firstHandler,firstFactory,transformer).append(secondMatcher,secondHandler,secondFactory,transformer).prepare(firstType,methodGraphCompiler,TypeValidation.ENABLED,methodFilter).compile(implementationTargetFactory,classFileVersion);
  assertThat(methodRegistry.getInstrumentedType(),is(typeDescription));
  assertThat(methodRegistry.getInstrumentedMethods().size(),is(1));
  assertThat(methodRegistry.getTypeInitializer(),is(typeInitializer));
  assertThat(methodRegistry.getLoadedTypeInitializer(),is(loadedTypeInitializer));
  verify(firstHandler).prepare(firstType);
  verify(secondHandler).prepare(secondType);
  verifyZeroInteractions(firstFactory);
  verifyZeroInteractions(secondFactory);
  assertThat(methodRegistry.target(instrumentedMethod),instanceOf(TypeWriter.MethodPool.Record.ForDefinedMethod.OfVisibilityBridge.class));
}
