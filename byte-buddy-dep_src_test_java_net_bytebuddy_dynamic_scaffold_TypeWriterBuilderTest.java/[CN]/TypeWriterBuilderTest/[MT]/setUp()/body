{
  when(instrumentedType.getSupertype()).thenReturn(superType);
  when(superType.getInternalName()).thenReturn(Type.getInternalName(Object.class));
  when(instrumentedType.getModifiers()).thenReturn(Opcodes.ACC_PUBLIC);
  when(instrumentedType.getInternalName()).thenReturn(FOO);
  when(instrumentedType.getName()).thenReturn(FOO);
  when(instrumentedType.getInterfaces()).thenReturn(emptyTypeList);
  when(emptyTypeList.toInternalNames()).thenReturn(null);
  when(firstField.getModifiers()).thenReturn(Opcodes.ACC_PUBLIC);
  when(firstField.getInternalName()).thenReturn(BAR);
  when(firstField.getDescriptor()).thenReturn(Type.getDescriptor(Object.class));
  when(secondField.getModifiers()).thenReturn(Opcodes.ACC_PUBLIC);
  when(secondField.getInternalName()).thenReturn(QUX);
  when(secondField.getDescriptor()).thenReturn(Type.getDescriptor(long.class));
  when(compiledFieldRegistry.target(any(FieldDescription.class))).thenReturn(fieldPoolEntry);
  when(fieldPoolEntry.getFieldAppenderFactory()).thenReturn(fieldAttributeAppenderFactory);
  when(fieldAttributeAppenderFactory.make(any(TypeDescription.class))).thenReturn(fieldAttributeAppender);
  when(compiledMethodRegistry.target(simpleMethod)).thenReturn(emptyImplementation);
  when(compiledMethodRegistry.target(fromAbstractMethod)).thenReturn(emptyImplementation);
  when(emptyImplementation.isDefineMethod()).thenReturn(true);
  when(emptyImplementation.getAttributeAppender()).thenReturn(methodAttributeAppender);
  when(emptyImplementation.getByteCodeAppender()).thenReturn(emptyImplementationByteCodeAppender);
  when(emptyImplementationByteCodeAppender.appendsCode()).thenReturn(true);
  when(emptyImplementationByteCodeAppender.apply(any(MethodVisitor.class),any(Instrumentation.Context.class),any(MethodDescription.class))).thenAnswer(new Answer<ByteCodeAppender.Size>(){
    @Override public ByteCodeAppender.Size answer(    InvocationOnMock invocation) throws Throwable {
      ((MethodVisitor)invocation.getArguments()[0]).visitInsn(Opcodes.RETURN);
      return new ByteCodeAppender.Size(0,1);
    }
  }
);
  when(compiledMethodRegistry.target(toAbstractMethod)).thenReturn(abstractImplementation);
  when(abstractImplementation.isDefineMethod()).thenReturn(true);
  when(abstractImplementation.getAttributeAppender()).thenReturn(methodAttributeAppender);
  when(abstractImplementation.getByteCodeAppender()).thenReturn(abstractImplementationByteCodeAppender);
  when(compiledMethodRegistry.target(skippedMethod)).thenReturn(skipImplementation);
  when(skipImplementation.isDefineMethod()).thenReturn(false);
  when(simpleMethod.getExceptionTypes()).thenReturn(emptyTypeList);
  when(simpleMethod.getInternalName()).thenReturn(BAR);
  when(simpleMethod.getModifiers()).thenReturn(Opcodes.ACC_PUBLIC);
  when(simpleMethod.getDescriptor()).thenReturn(Type.getMethodDescriptor(Type.VOID_TYPE));
  when(fromAbstractMethod.getExceptionTypes()).thenReturn(emptyTypeList);
  when(fromAbstractMethod.getInternalName()).thenReturn(BAZ);
  when(fromAbstractMethod.getModifiers()).thenReturn(Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT);
  when(fromAbstractMethod.isAbstract()).thenReturn(true);
  when(fromAbstractMethod.getDescriptor()).thenReturn(Type.getMethodDescriptor(Type.VOID_TYPE));
  when(toAbstractMethod.getExceptionTypes()).thenReturn(emptyTypeList);
  when(toAbstractMethod.getInternalName()).thenReturn(QUX);
  when(toAbstractMethod.getModifiers()).thenReturn(Opcodes.ACC_PUBLIC);
  when(toAbstractMethod.getDescriptor()).thenReturn(Type.getMethodDescriptor(Type.VOID_TYPE));
  when(classVisitorWrapper.wrap(any(ClassVisitor.class))).thenAnswer(new Answer<ClassVisitor>(){
    @Override public ClassVisitor answer(    InvocationOnMock invocation) throws Throwable {
      return (ClassVisitor)invocation.getArguments()[0];
    }
  }
);
  typeWriter=new TypeWriter.Builder<Object>(instrumentedType,loadedTypeInitializer,instrumentationContext,ClassFileVersion.forCurrentJavaVersion(),TypeWriter.Builder.ClassWriterProvider.CleanCopy.INSTANCE).build(classVisitorWrapper);
  verify(classVisitorWrapper).wrap(any(ClassWriter.class));
}
