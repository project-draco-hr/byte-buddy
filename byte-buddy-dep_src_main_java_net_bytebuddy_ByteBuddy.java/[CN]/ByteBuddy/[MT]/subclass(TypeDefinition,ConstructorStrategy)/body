{
  TypeDescription.Generic actualSuperType=superType.asGenericType();
  List<TypeDescription.Generic> interfaceTypes=this.interfaceTypes;
  if (superType.isPrimitive() || superType.isArray() || superType.asErasure().isFinal()) {
    throw new IllegalArgumentException("Cannot subclass primitive, array or final types: " + superType);
  }
 else   if (superType.asErasure().isInterface()) {
    actualSuperType=TypeDescription.Generic.OBJECT;
    interfaceTypes=CompoundList.of(interfaceTypes,superType.asGenericType());
  }
  return new SubclassDynamicTypeBuilder<T>(classFileVersion,namingStrategy.subclass(superType.asErasure()),auxiliaryTypeNamingStrategy,implementationContextFactory,interfaceTypes,modifiers.resolve(superType.asErasure().getModifiers() & ~TypeManifestation.ANNOTATION.getMask()),typeAttributeAppender,ignoredMethods,classVisitorWrapper,new FieldRegistry.Default(),methodRegistry,methodGraphCompiler,defaultFieldAttributeAppenderFactory,defaultMethodAttributeAppenderFactory,actualSuperType,constructorStrategy);
}
