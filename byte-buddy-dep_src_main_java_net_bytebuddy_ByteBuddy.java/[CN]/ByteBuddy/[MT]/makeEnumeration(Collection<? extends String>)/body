{
  if (unique(nonNull(values)).isEmpty()) {
    throw new IllegalArgumentException("Require at least one enumeration constant");
  }
  return new SubclassDynamicTypeBuilder<Enum<?>>(classFileVersion,nonNull(namingStrategy.subclass(TypeDescription.ENUM)),auxiliaryTypeNamingStrategy,implementationContextFactory,TypeDescription.ENUM,interfaceTypes,Visibility.PUBLIC.getMask() | TypeManifestation.FINAL.getMask() | EnumerationState.ENUMERATION.getMask(),typeAttributeAppender,ignoredMethods,classVisitorWrapper,new FieldRegistry.Default(),methodRegistry,methodGraphCompiler,defaultFieldAttributeAppenderFactory,defaultMethodAttributeAppenderFactory,ConstructorStrategy.Default.NO_CONSTRUCTORS).defineConstructor(Arrays.<Class<?>>asList(String.class,int.class),Visibility.PRIVATE).intercept(MethodCall.invoke(TypeDescription.ENUM.getDeclaredMethods().filter(isConstructor().and(takesArguments(String.class,int.class))).getOnly()).withArgument(0,1)).defineMethod(EnumerationImplementation.ENUM_VALUE_OF_METHOD_NAME,TargetType.class,Collections.<Class<?>>singletonList(String.class),Visibility.PUBLIC,Ownership.STATIC).intercept(MethodCall.invoke(TypeDescription.ENUM.getDeclaredMethods().filter(named(EnumerationImplementation.ENUM_VALUE_OF_METHOD_NAME).and(takesArguments(Class.class,String.class))).getOnly()).withOwnType().withArgument(0).withAssigner(Assigner.DEFAULT,Assigner.Typing.DYNAMIC)).defineMethod(EnumerationImplementation.ENUM_VALUES_METHOD_NAME,TargetType[].class,Collections.<Class<?>>emptyList(),Visibility.PUBLIC,Ownership.STATIC).intercept(new EnumerationImplementation(new ArrayList<String>(values)));
}
