{
  if (values.isEmpty()) {
    throw new IllegalArgumentException("Require at least one enumeration constant");
  }
  TypeDescription.Generic enumType=TypeDescription.Generic.Builder.parameterizedType(Enum.class,TargetType.class).asType();
  return new SubclassDynamicTypeBuilder<Enum<?>>(InstrumentedType.Default.subclass(namingStrategy.subclass(enumType),ModifierContributor.Resolver.of(Visibility.PUBLIC,TypeManifestation.FINAL,EnumerationState.ENUMERATION).resolve(),enumType),classFileVersion,auxiliaryTypeNamingStrategy,annotationValueFilterFactory,annotationRetention,implementationContextFactory,methodGraphCompiler,typeValidation,ignoredMethods,ConstructorStrategy.Default.NO_CONSTRUCTORS).defineConstructor(Visibility.PRIVATE).withParameters(String.class,int.class).intercept(MethodCall.invoke(enumType.getDeclaredMethods().filter(isConstructor().and(takesArguments(String.class,int.class))).getOnly()).withArgument(0,1)).defineMethod(EnumerationImplementation.ENUM_VALUE_OF_METHOD_NAME,TargetType.class,Visibility.PUBLIC,Ownership.STATIC).withParameters(String.class).intercept(MethodCall.invoke(enumType.getDeclaredMethods().filter(named(EnumerationImplementation.ENUM_VALUE_OF_METHOD_NAME).and(takesArguments(Class.class,String.class))).getOnly()).withOwnType().withArgument(0).withAssigner(Assigner.DEFAULT,Assigner.Typing.DYNAMIC)).defineMethod(EnumerationImplementation.ENUM_VALUES_METHOD_NAME,TargetType[].class,Visibility.PUBLIC,Ownership.STATIC).intercept(new EnumerationImplementation(new ArrayList<String>(values)));
}
