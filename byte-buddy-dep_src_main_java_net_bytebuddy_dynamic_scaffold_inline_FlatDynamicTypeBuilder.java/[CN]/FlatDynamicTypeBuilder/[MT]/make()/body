{
  MethodRegistry.Compiled compiledMethodRegistry=methodRegistry.compile(applyRecordedMembersTo(new FlatInstrumentedType(classFileVersion,targetType,interfaceTypes,modifiers,namingStrategy)),methodLookupEngineFactory.make(classFileVersion),instrumentationTargetFactoryProvider.makeFactory(bridgeMethodResolverFactory),MethodRegistry.Compiled.Entry.Skip.INSTANCE);
  MethodLookupEngine.Finding finding=compiledMethodRegistry.getFinding();
  TypeExtensionDelegate typeExtensionDelegate=new TypeExtensionDelegate(finding.getTypeDescription(),classFileVersion);
  try {
    InputStream classFile=exists(classFileLocator.classFileFor(targetType));
    try {
      ClassReader classReader=new ClassReader(classFile);
      new TypeWriter.Builder<T>(finding.getTypeDescription(),compiledMethodRegistry.getLoadedTypeInitializer(),typeExtensionDelegate,classFileVersion,new TypeWriter.Builder.ClassWriterProvider.ForClassReader(classReader));
    }
  finally {
      classFile.close();
    }
  }
 catch (  IOException e) {
    throw new IllegalStateException(e);
  }
  return null;
}
