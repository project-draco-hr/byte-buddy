{
  String binaryTypeName=internalTypeName.replace('/','.');
  try {
    BinaryLocator.Initialized initialized=binaryLocator.initialize(binaryTypeName,binaryRepresentation,classLoader);
    TypeDescription typeDescription=initialized.getTypePool().describe(binaryTypeName).resolve();
    for (    Transformation transformation : transformations) {
      if (transformation.matches(typeDescription,classLoader,classBeingRedefined,protectionDomain)) {
        DynamicType.Unloaded<?> dynamicType=initializationStrategy.apply(transformation.transform(byteBuddy.rebase(typeDescription,initialized.getClassFileLocator(),methodNameTransformer),typeDescription)).make();
        Map<TypeDescription,LoadedTypeInitializer> loadedTypeInitializers=dynamicType.getLoadedTypeInitializers();
        if (loadedTypeInitializers.size() > 1) {
          ClassInjector classInjector=classLoader == null ? bootstrapInjectionStrategy.make(protectionDomain) : new ClassInjector.UsingReflection(classLoader,protectionDomain,accessControlContext,PackageDefinitionStrategy.NoOp.INSTANCE,true);
          for (          Map.Entry<TypeDescription,Class<?>> auxiliary : classInjector.inject(dynamicType.getRawAuxiliaryTypes()).entrySet()) {
            initializationStrategy.initialize(auxiliary.getValue(),loadedTypeInitializers.get(auxiliary.getKey()));
          }
        }
        initializationStrategy.register(binaryTypeName,classLoader,loadedTypeInitializers.get(dynamicType.getTypeDescription()));
        listener.onTransformation(typeDescription,dynamicType);
        return dynamicType.getBytes();
      }
    }
    listener.onIgnored(binaryTypeName);
    return NO_TRANSFORMATION;
  }
 catch (  Throwable throwable) {
    listener.onError(binaryTypeName,throwable);
    return NO_TRANSFORMATION;
  }
 finally {
    listener.onComplete(binaryTypeName);
  }
}
