{
  ClassFileTransformer classFileTransformer=makeRaw();
  instrumentation.addTransformer(classFileTransformer,redefinitionStrategy.isRetransforming(instrumentation));
  if (nativeMethodStrategy.isEnabled(instrumentation)) {
    instrumentation.setNativeMethodPrefix(classFileTransformer,nativeMethodStrategy.getPrefix());
  }
  lambdaInstrumentationStrategy.apply(byteBuddy,instrumentation,classFileTransformer);
  if (redefinitionStrategy.isEnabled()) {
    RedefinitionStrategy.Collector collector=redefinitionStrategy.makeCollector(transformation);
    for (    Class<?> type : instrumentation.getAllLoadedClasses()) {
      TypeDescription typeDescription=new TypeDescription.ForLoadedType(type);
      try {
        if (!instrumentation.isModifiableClass(type) || !collector.consider(type,ignoredTypeMatcher)) {
          try {
            try {
              listener.onIgnored(typeDescription,type.getClassLoader());
            }
  finally {
              listener.onComplete(typeDescription.getName(),type.getClassLoader());
            }
          }
 catch (          Throwable ignored) {
          }
        }
      }
 catch (      Throwable throwable) {
        try {
          try {
            listener.onError(typeDescription.getName(),type.getClassLoader(),throwable);
          }
  finally {
            listener.onComplete(typeDescription.getName(),type.getClassLoader());
          }
        }
 catch (        Throwable ignored) {
        }
      }
    }
    try {
      collector.apply(instrumentation,binaryLocator,listener);
    }
 catch (    UnmodifiableClassException exception) {
      throw new IllegalStateException("Cannot modify at least one class: " + collector,exception);
    }
catch (    ClassNotFoundException exception) {
      throw new IllegalStateException("Cannot find at least one class: " + collector,exception);
    }
  }
  return classFileTransformer;
}
