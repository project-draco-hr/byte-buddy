{
  Map<Instrumentation,Entry> prepared=new HashMap<Instrumentation,Entry>(entries.size());
  LinkedHashMap<Instrumentation,MethodMatcher> instrumentationMethods=new LinkedHashMap<Instrumentation,MethodMatcher>();
  for (  Entry entry : entries) {
    if (!prepared.containsKey(entry.instrumentation)) {
      MethodList beforeMethods=instrumentedType.getDeclaredMethods();
      instrumentedType=entry.instrumentation.prepare(instrumentedType);
      prepared.put(entry.instrumentation,entry);
      if (beforeMethods.size() < instrumentedType.getDeclaredMethods().size()) {
        instrumentationMethods.put(entry.instrumentation,new ListDifferenceMethodMatcher(beforeMethods,instrumentedType.getDeclaredMethods()));
      }
    }
  }
  List<MethodRegistry.Default.Compiled.Entry> compiledEntries=new LinkedList<Compiled.Entry>();
  LinkedHashMap<Instrumentation,ByteCodeAppender> byteCodeAppenders=new LinkedHashMap<Instrumentation,ByteCodeAppender>(prepared.size());
  for (  Entry entry : entries) {
    MethodMatcher methodMatcher=entry.latentMethodMatcher.manifest(instrumentedType);
    ByteCodeAppender byteCodeAppender=prepared.get(entry.instrumentation).instrumentation.appender(instrumentedType);
    MethodAttributeAppender attributeAppender=entry.attributeAppenderFactory.make(instrumentedType);
    compiledEntries.add(new Compiled.Entry(methodMatcher,byteCodeAppender,attributeAppender));
    byteCodeAppenders.put(entry.instrumentation,byteCodeAppender);
  }
  for (  Map.Entry<Instrumentation,MethodMatcher> entry : instrumentationMethods.entrySet()) {
    compiledEntries.add(0,new Compiled.Entry(entry.getValue(),byteCodeAppenders.get(entry.getKey()),MethodAttributeAppender.NoOp.INSTANCE));
  }
  return new Compiled(new ArrayList<Compiled.Entry>(compiledEntries),fallback);
}
