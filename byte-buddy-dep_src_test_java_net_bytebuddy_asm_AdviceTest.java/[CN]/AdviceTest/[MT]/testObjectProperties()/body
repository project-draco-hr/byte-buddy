{
  ObjectPropertyAssertion.of(Advice.class).apply();
  ObjectPropertyAssertion.of(Advice.AdviceVisitor.CodeCopier.class).applyBasic();
  ObjectPropertyAssertion.of(Advice.Dispatcher.Inactive.class).apply();
  ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.ForMethodEnter.class).refine(new ObjectPropertyAssertion.Refinement<MethodDescription.InDefinedShape>(){
    @Override public void apply(    MethodDescription.InDefinedShape mock){
      when(mock.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
    }
  }
).apply();
  final Iterator<StackSize> iterator=Arrays.asList(StackSize.values()).iterator();
  ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.ForMethodExit.class).refine(new ObjectPropertyAssertion.Refinement<MethodDescription.InDefinedShape>(){
    @Override public void apply(    MethodDescription.InDefinedShape mock){
      when(mock.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
      try {
        when(mock.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(TrivialAdvice.class.getDeclaredMethod(EXIT).getDeclaredAnnotations()));
      }
 catch (      Exception exception) {
        throw new AssertionError(exception);
      }
    }
  }
).refine(new ObjectPropertyAssertion.Refinement<TypeDescription>(){
    @Override public void apply(    TypeDescription mock){
      when(mock.getStackSize()).thenReturn(iterator.next());
    }
  }
).apply();
  ObjectPropertyAssertion.of(Advice.Dispatcher.Active.CodeTranslationVisitor.ReturnValueDiscarding.class).applyBasic();
  ObjectPropertyAssertion.of(Advice.Dispatcher.Active.CodeTranslationVisitor.ReturnValueRetaining.class).applyBasic();
}
