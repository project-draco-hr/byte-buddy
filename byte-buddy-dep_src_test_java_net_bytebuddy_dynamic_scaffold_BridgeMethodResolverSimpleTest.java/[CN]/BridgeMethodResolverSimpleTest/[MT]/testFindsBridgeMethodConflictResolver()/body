{
  TypeDescription target=new TypeDescription.ForLoadedType(Baz.class);
  MethodList invokableMethods=new MethodLookupEngine.Default(MethodLookupEngine.Default.DefaultMethodLookup.DISABLED).process(target).getInvokableMethods();
  MethodList relevantMethods=invokableMethods.filter(not(isDeclaredBy(Object.class).or(isConstructor())));
  assertThat(relevantMethods.size(),is(3));
  when(conflictHandler.choose(any(MethodDescription.class),any(MethodList.class))).thenReturn(bridgeTarget);
  when(bridgeTarget.isResolved()).thenReturn(true);
  when(bridgeTarget.extract()).thenReturn(methodDescription);
  BridgeMethodResolver bridgeMethodResolver=BridgeMethodResolver.Simple.of(invokableMethods,conflictHandler);
  assertThat(bridgeMethodResolver.resolve(relevantMethods.filter(isBridge()).getOnly()),is(methodDescription));
  ArgumentCaptor<MethodList> capturedConflictHandlerCandidates=ArgumentCaptor.forClass(MethodList.class);
  verify(conflictHandler).choose(eq(relevantMethods.filter(isBridge()).getOnly()),capturedConflictHandlerCandidates.capture());
  assertThat(capturedConflictHandlerCandidates.getValue().size(),is(2));
  assertThat(capturedConflictHandlerCandidates.getValue(),containsAllOf(relevantMethods.filter(not(isBridge()))));
  verifyNoMoreInteractions(conflictHandler);
  verify(bridgeTarget).isResolved();
  verify(bridgeTarget).extract();
  verifyNoMoreInteractions(bridgeTarget);
}
