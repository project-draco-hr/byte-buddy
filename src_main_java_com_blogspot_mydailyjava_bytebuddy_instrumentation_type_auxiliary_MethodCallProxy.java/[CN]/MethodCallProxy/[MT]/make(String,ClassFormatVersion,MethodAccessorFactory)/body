{
  MethodDescription proxiedMethod=methodAccessorFactory.requireAccessorMethodFor(this.proxiedMethod);
  int fieldIndex=0;
  InstrumentedType proxy=new SubclassInstumentedType(ClassFormatVersion.forCurrentJavaVersion(),new TypeDescription.ForLoadedType(Object.class),new TypeList.ForLoadedType(Arrays.<Class<?>>asList(Runnable.class,Callable.class)),Opcodes.ACC_PUBLIC,new NamingStrategy.Fixed(auxiliaryTypeName));
  List<FieldAccess.Defined> fieldAccess=new LinkedList<FieldAccess.Defined>();
  List<TypeDescription> fieldTypes=new ArrayList<TypeDescription>();
  if (!proxiedMethod.isStatic()) {
    proxy=registerFieldFor(proxy,proxiedMethod.getDeclaringType(),fieldIndex++,fieldAccess,fieldTypes);
  }
  for (  TypeDescription parameterType : proxiedMethod.getParameterTypes()) {
    proxy=registerFieldFor(proxy,parameterType,fieldIndex++,fieldAccess,fieldTypes);
  }
  proxy=proxy.withMethod(MethodDescription.CONSTRUCTOR_INTERNAL_NAME,new TypeDescription.ForLoadedType(void.class),fieldTypes,ModifierContributor.EMPTY_MASK);
  SubclassInstrumentationContextDelegate contextDelegate=new SubclassInstrumentationContextDelegate(proxy);
  Instrumentation.Context instrumentationContext=new Instrumentation.Context.Default(classFormatVersion,contextDelegate,contextDelegate);
  MethodDelegate methodDelegate=new MethodDelegate(fieldAccess,proxiedMethod,assigner);
  ConstructorDelegate constructorDelegate=new ConstructorDelegate(fieldAccess);
  return new TypeWriter.Builder<Object>(proxy,instrumentationContext,ClassFormatVersion.forCurrentJavaVersion()).build(new ClassVisitorWrapper.Chain()).fields().write(proxy.getDeclaredFields(),FieldRegistry.Compiled.NoOp.INSTANCE).methods().write(proxy.getDeclaredMethods().filter(methodDelegate),methodDelegate).write(proxy.getDeclaredMethods().filter(constructorDelegate),constructorDelegate).write(contextDelegate.getProxiedMethods(),contextDelegate).make();
}
