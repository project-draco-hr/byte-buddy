{
  MethodRegistry.Prepared preparedMethodRegistry=constructorStrategy.inject(methodRegistry,defaultMethodAttributeAppenderFactory).prepare(applyConstructorStrategy(applyRecordedMembersTo(new SubclassInstrumentedType(classFileVersion,targetType,interfaceTypes,modifiers,namingStrategy))));
  MethodRegistry.Compiled compiledMethodRegistry=preparedMethodRegistry.compile(new SubclassInstrumentationTarget.Factory(bridgeMethodResolverFactory),methodLookupEngineFactory.make(classFileVersion),MethodRegistry.Compiled.Entry.Skip.INSTANCE);
  return new TypeWriter.Default<T>(preparedMethodRegistry.getInstrumentedType(),preparedMethodRegistry.getLoadedTypeInitializer(),Collections.<DynamicType>emptyList(),new TypeWriter.Engine.ForCreation(preparedMethodRegistry.getInstrumentedType(),classFileVersion,compiledMethodRegistry.getInvokableMethods().filter(isOverridable().and(not(ignoredMethods)).or(isDeclaredBy(preparedMethodRegistry.getInstrumentedType()))),classVisitorWrapperChain,attributeAppender,fieldRegistry.prepare(preparedMethodRegistry.getInstrumentedType()).compile(TypeWriter.FieldPool.Entry.NoOp.INSTANCE),compiledMethodRegistry)).make(new TypeExtensionDelegate(preparedMethodRegistry.getInstrumentedType(),classFileVersion));
}
