{
  MethodRegistry.Compiled compiledMethodRegistry=constructorStrategy.inject(methodRegistry,defaultMethodAttributeAppenderFactory).prepare(applyConstructorStrategy(applyRecordedMembersTo(new SubclassInstrumentedType(classFileVersion,targetType,interfaceTypes,modifiers,namingStrategy)))).compile(new SubclassInstrumentationTarget.Factory(bridgeMethodResolverFactory,SubclassInstrumentationTarget.OriginTypeIdentifier.SUPER_TYPE),methodLookupEngineFactory.make(classFileVersion.isSupportsDefaultMethods()),MethodRegistry.Compiled.Entry.Skip.INSTANCE);
  return new TypeWriter.Default<T>(compiledMethodRegistry.getInstrumentedType(),compiledMethodRegistry.getLoadedTypeInitializer(),Collections.<DynamicType>emptyList(),classFileVersion,new TypeWriter.Engine.ForCreation(compiledMethodRegistry.getInstrumentedType(),classFileVersion,compiledMethodRegistry.getInvokableMethods().filter(isOverridable().and(not(ignoredMethods)).<MethodDescription>or(isDeclaredBy(compiledMethodRegistry.getInstrumentedType()))),classVisitorWrapperChain,attributeAppender,fieldRegistry.prepare(compiledMethodRegistry.getInstrumentedType()).compile(TypeWriter.FieldPool.Entry.NoOp.INSTANCE),compiledMethodRegistry)).make();
}
