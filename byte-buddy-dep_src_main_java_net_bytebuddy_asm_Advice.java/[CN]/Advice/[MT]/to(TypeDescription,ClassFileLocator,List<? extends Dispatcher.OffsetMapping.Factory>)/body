{
  try {
    Dispatcher.Unresolved methodEnter=Dispatcher.Inactive.INSTANCE, methodExit=Dispatcher.Inactive.INSTANCE;
    for (    MethodDescription.InDefinedShape methodDescription : typeDescription.getDeclaredMethods()) {
      methodEnter=locate(OnMethodEnter.class,INLINE_ENTER,methodEnter,methodDescription);
      methodExit=locate(OnMethodExit.class,INLINE_EXIT,methodExit,methodDescription);
    }
    if (!methodEnter.isAlive() && !methodExit.isAlive()) {
      throw new IllegalArgumentException("No advice defined by " + typeDescription);
    }
    ClassFileLocator.Resolution binaryRepresentation=methodEnter.isBinary() || methodExit.isBinary() ? classFileLocator.locate(typeDescription.getName()) : ClassFileLocator.Resolution.Illegal.INSTANCE;
    Dispatcher.Resolved.ForMethodEnter resolved=methodEnter.asMethodEnter(userFactories,binaryRepresentation);
    return new Advice(resolved,methodExit.asMethodExitTo(userFactories,binaryRepresentation,resolved));
  }
 catch (  IOException exception) {
    throw new IllegalStateException("Error reading class file of " + typeDescription,exception);
  }
}
