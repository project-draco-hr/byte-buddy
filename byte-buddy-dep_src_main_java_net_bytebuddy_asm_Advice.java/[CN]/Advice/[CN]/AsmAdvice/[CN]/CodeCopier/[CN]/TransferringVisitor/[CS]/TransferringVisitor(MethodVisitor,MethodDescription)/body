{
  super(Opcodes.ASM5,methodVisitor);
  accessMappings=new HashMap<Integer,AccessMapping>();
  for (  ParameterDescription parameter : inlinedMethod.getParameters()) {
    if (parameter.getDeclaredAnnotations().isAnnotationPresent(This.class)) {
      if (instrumentedMethod.isStatic()) {
        throw new IllegalStateException("Static methods do not imply a this reference for " + parameter);
      }
      accessMappings.put(parameter.getOffset(),AccessMapping.ForMethodArgument.ofThisReference());
    }
 else     if (parameter.getDeclaredAnnotations().isAnnotationPresent(EntranceValue.class)) {
      accessMappings.put(parameter.getOffset(),new AccessMapping.ForEntranceValue(instrumentedMethod));
    }
 else     if (parameter.getDeclaredAnnotations().isAnnotationPresent(ReturnValue.class)) {
      accessMappings.put(parameter.getOffset(),new AccessMapping.ForReturnValue(instrumentedMethod));
    }
 else {
      AnnotationDescription.Loadable<Argument> argument=parameter.getDeclaredAnnotations().ofType(Argument.class);
      int index=argument == null ? parameter.getIndex() : argument.loadSilent().value();
      if (instrumentedMethod.getParameters().size() <= index) {
        throw new IllegalStateException(instrumentedMethod + " does not define a parameter of index " + index);
      }
 else       if (!instrumentedMethod.getParameters().get(index).getType().asErasure().isAssignableTo(parameter.getType().asErasure())) {
        throw new IllegalStateException(parameter + " is not assignable to " + instrumentedMethod.getParameters().get(index));
      }
      accessMappings.put(parameter.getOffset(),new AccessMapping.ForMethodArgument(instrumentedMethod.getParameters().get(index).getOffset()));
    }
  }
  offsetCorrection=instrumentedMethod.getStackSize() - inlinedMethod.getStackSize();
  endOfMethod=new Label();
}
