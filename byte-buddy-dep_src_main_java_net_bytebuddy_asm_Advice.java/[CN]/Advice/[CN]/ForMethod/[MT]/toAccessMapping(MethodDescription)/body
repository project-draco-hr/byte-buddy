{
  Map<Integer,AccessMapping> accessMappings=new HashMap<Integer,AccessMapping>();
  for (  ParameterDescription parameter : methodDescription.getParameters()) {
    if (parameter.getDeclaredAnnotations().isAnnotationPresent(This.class)) {
      if (instrumentedMethod.isStatic()) {
        throw new IllegalStateException("Static methods do not imply a this reference for " + parameter);
      }
      accessMappings.put(parameter.getOffset(),AccessMapping.ForMethodArgument.ofThisReference());
    }
 else     if (parameter.getDeclaredAnnotations().isAnnotationPresent(Entry.class)) {
      accessMappings.put(parameter.getOffset(),new AccessMapping.ForEntranceValue(instrumentedMethod));
    }
 else     if (parameter.getDeclaredAnnotations().isAnnotationPresent(Return.class)) {
      accessMappings.put(parameter.getOffset(),new AccessMapping.ForReturnValue(instrumentedMethod));
    }
 else {
      AnnotationDescription.Loadable<Argument> argument=parameter.getDeclaredAnnotations().ofType(Argument.class);
      int index=argument == null ? parameter.getIndex() : argument.loadSilent().value();
      if (instrumentedMethod.getParameters().size() <= index) {
        throw new IllegalStateException(instrumentedMethod + " does not define a parameter of index " + index);
      }
 else       if (!instrumentedMethod.getParameters().get(index).getType().asErasure().isAssignableTo(parameter.getType().asErasure())) {
        throw new IllegalStateException(parameter + " is not assignable to " + instrumentedMethod.getParameters().get(index));
      }
      accessMappings.put(parameter.getOffset(),new AccessMapping.ForMethodArgument(instrumentedMethod.getParameters().get(index).getOffset()));
    }
  }
  return accessMappings;
}
