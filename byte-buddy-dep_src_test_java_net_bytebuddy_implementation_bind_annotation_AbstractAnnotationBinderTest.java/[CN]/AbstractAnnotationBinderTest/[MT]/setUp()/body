{
  when(sourceDeclaringType.asRawType()).thenReturn(sourceDeclaringType);
  when(targetDeclaringType.asRawType()).thenReturn(targetDeclaringType);
  when(source.getDeclaringType()).thenReturn(sourceDeclaringType);
  annotation=mock(annotationType);
  doReturn(annotationType).when(annotation).annotationType();
  annotationDescription=AnnotationDescription.ForLoadedAnnotation.of(annotation);
  when(source.getParameters()).thenReturn(sourceParameterList);
  when(sourceParameterList.asTypeList()).thenReturn(sourceTypeList);
  when(sourceTypeList.asRawTypes()).thenReturn(rawSourceTypeList);
  when(assigner.assign(any(TypeDescription.class),any(TypeDescription.class),anyBoolean())).thenReturn(stackManipulation);
  when(implementationTarget.getTypeDescription()).thenReturn(instrumentedType);
  when(implementationTarget.getOriginType()).thenReturn(instrumentedType);
  when(instrumentedType.asRawType()).thenReturn(instrumentedType);
  when(instrumentedType.iterator()).then(new Answer<Iterator<GenericTypeDescription>>(){
    @Override public Iterator<GenericTypeDescription> answer(    InvocationOnMock invocationOnMock) throws Throwable {
      return Collections.<GenericTypeDescription>singleton(instrumentedType).iterator();
    }
  }
);
}
